// Generated by LiveScript 1.2.0
(function(){
  var requires, assert, expect, _, Person, OrderedHash, Decorations;
  requires = require('../../requires');
  requires.test('test_setup');
  assert = require('chai').assert;
  expect = require('chai').expect;
  _ = require('prelude-ls');
  Person = requires.clazz('person');
  OrderedHash = require('jsclass/src/hash').OrderedHash;
  Decorations = requires.lib('decorations');
  console.log('Decorations', Decorations);
  describe('Decorations', function(){
    var decs;
    decs = {};
    describe('create instance', function(){
      context('no args', function(){
        before(function(){
          return decs.empty = new Decorations;
        });
        specify('has Hash registry', function(){
          return expect(decs.empty.repository.isEmpty()).to.be['true'];
        });
        return specify('has no keys', function(){
          return expect(decs.empty.repository.keys().length).to.equal(0);
        });
      });
      return context('with hash', function(){
        before(function(){
          return decs.basic = new Decorations({
            'x': function(){
              return 'x';
            },
            y: function(){
              return 'y';
            }
          });
        });
        specify('has Hash registry', function(){
          return decs.basic.repository.should.not.be.empty;
        });
        specify('has 2 keys', function(){
          return expect(decs.basic.repository.keys().length).to.equal(2);
        });
        specify('repo x = 1', function(){
          return expect(decs.basic.find('x')()).to.equal('x');
        });
        return specify('repo y = 2', function(){
          return expect(decs.basic.find('y')()).to.equal('y');
        });
      });
    });
    describe('find', function(){
      context('empty repo', function(){
        before(function(){
          return decs.empty = new Decorations;
        });
        return specify('x not found', function(){
          return expect(decs.empty.find('x')).to.equal(null);
        });
      });
      context('repo with xx', function(){
        before(function(){
          return decs.basic = new Decorations({
            xx: 'y'
          });
        });
        return specify('not found', function(){
          return expect(decs.basic.find('x')).to.equal(null);
        });
      });
      return context('repo with x', function(){
        before(function(){
          return decs.basic = new Decorations({
            x: 'y'
          });
        });
        return specify('found', function(){
          return expect(decs.basic.find('x')).to.equal('y');
        });
      });
    });
    describe('register', function(){
      context('with x', function(){
        before(function(){
          return decs.setme = new Decorations;
        });
        return specify('x is found', function(){
          return expect(function(){
            return decs.setme.register('x');
          }).to['throw'];
        });
      });
      context('with x, Function', function(){
        before(function(){
          decs.setme = new Decorations;
          return decs.setme.register('x', function(){
            return '2';
          });
        });
        specify('x is found', function(){
          return expect(decs.setme.find('x')()).to.equal('2');
        });
        return specify('xx is not found', function(){
          return expect(decs.setme.find('xx')).to.equal(null);
        });
      });
      return context('with Hash', function(){
        before(function(){
          decs.setme = new Decorations;
          return decs.setme.register({
            z: function(){
              return '3';
            }
          });
        });
        specify('z is found', function(){
          return expect(decs.setme.find('z')).to.not.equal(null);
        });
        specify('z is function', function(){
          return expect(decs.setme.find('z')()).to.equal('3');
        });
        return specify('zz is not found', function(){
          return expect(decs.setme.find('zz')).to.equal(null);
        });
      });
    });
    return describe('decorate', function(){
      var dataObjs;
      dataObjs = {};
      before(function(){
        decs.setme = new Decorations;
        decs.setme.register({
          z: function(){
            return '3';
          }
        });
        dataObjs.empty = {};
        dataObjs.wmodel = {
          model: 'z'
        };
        return dataObjs.wclazz = {
          clazz: 'z'
        };
      });
      context('with data-obj', function(){
        context('with no model or clazz', function(){
          return specify('should throw', function(){
            return expect(function(){
              return decs.setme.decorate(dataObjs.empty);
            }).to['throw'];
          });
        });
        context('with model', function(){
          return specify('should not throw', function(){
            return expect(decs.setme.decorate(dataObjs.wmodel)).to.not['throw'];
          });
        });
        return context('with clazz', function(){
          return specify('should not throw', function(){
            return expect(decs.setme.decorate(dataObjs.wclazz)).to.not['throw'];
          });
        });
      });
      context('with data-obj, model', function(){
        context('invalid model', function(){
          return specify('should throw', function(){
            return expect(function(){
              return decs.setme.decorate(dataObjs.empty, 'unknown');
            }).to['throw'];
          });
        });
        return context('valid model', function(){
          return specify('should not throw', function(){
            return expect(decs.setme.decorate(dataObjs.empty, 'z')).to.not['throw'];
          });
        });
      });
      return context('with Object model: data-obj', function(){
        context('invalid model', function(){
          return specify('should throw', function(){
            return expect(function(){
              return decs.setme.decorate({
                unknown: dataObjs.empty
              });
            }).to['throw'];
          });
        });
        return context('valid model', function(){
          return specify('should not throw', function(){
            return expect(decs.setme.decorate({
              z: dataObjs.empty
            })).to.not['throw'];
          });
        });
      });
    });
  });
}).call(this);
